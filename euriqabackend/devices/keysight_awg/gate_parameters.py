"""Data Structures to aid in loading & saving gate data.

Meant to store both gate data & gate calibration data, and together provide a
calibrated gate which drives the gate very precisely.

Gate data is generated by an analytical solver that takes into account the modes & their
frequencies to create an XX gate.
"""
import copy
import functools
import hashlib
import itertools
import logging
import os
import pathlib
import pickle
import string
import time
import typing

import h5py
import numpy as np
import pandas as pd
from more_itertools import flatten
from more_itertools import sliced

import euriqabackend.utilities.hashing as eur_hash
from . import common_types

_LOGGER = logging.getLogger(__name__)


class GateSolution:
    """A data structure to hold calculated gate solutions.

    Gate solutions provide waveform information to drive the gate, such as
    frequency, amplitude, modulation types, etc. See :attr:`common_types.XXGateParams`.
    """

    _GATE_INDEX_NAMES = ("lower_slot", "upper_slot")
    _HDF_KEYS = {
        # names to HDF key mappings, used for storing data to HDF file.
        "ions": "number_of_ions",
        "df": "gate_solutions_df",
        "hash": "solutions_hash",
        "modify_time": "solution_load_timestamp",
        "save_time": "solution_save_timestamp",
        "solution_path": "solution_location_path",
    }
    # extra columns to be added to the dataframe. more for subclasses than this
    _EXTRA_DF_COLUMNS = dict()

    def __init__(
        self,
        num_ions: int,
        dataframe: pd.DataFrame = None,
        solutions_hash: str = None,
        modify_time: str = None,
        path: typing.Union[str, pathlib.Path] = None,
    ):
        """Create a :class:`GateSolution` data structure.

        Arguments are a little complicated. If you want to copy an existing
        :class:`GateSolution`, or build one from a dataframe, you use the arguments
        ``dataframe``, ``solutions_hash``, ``modify_time`` (optional).

        If you are constructing a :class:`GateSolution` from a directory
        (e.g. the output of Laird's :mod:`GateSolver`), then you pass ``path``.

        If you don't pass any of those, it will technically work but is not intended
        use case.
        """
        self.num_ions = num_ions
        self._possible_gates = list(common_types.gen_all_IonPairs(num_ions))
        self._possible_slots = list(common_types.gen_all_SlotPairs(num_ions))
        # Specialize the ion -> slot conversion function for this # of ions
        self._ion_to_slot_func = functools.partial(
            common_types.ion_to_slot, N_ions=self.num_ions
        )
        self.load_path = pathlib.Path(path) if path not in {None, b"None"} else None

        # used to construct from existing dataframe/solution hash, ignored otherwise
        # Must provide both df & soln_hash, OR path
        if (
            dataframe is not None
            and solutions_hash is not None
            and self._validate_df(dataframe)
            and self._validate_hash(solutions_hash)
        ):
            self.gate_parameters_df = dataframe
            self.solutions_hash = solutions_hash
            self._modify_time = (
                modify_time if modify_time is not None else time.gmtime()
            )
        elif path is not None:
            self.load_gate_solutions(path)
            self._validate_df(self.gate_parameters_df)
            # TODO: drop NaN rows?
        else:
            _LOGGER.warning(
                "Creating %s without a solution hash. Initializing to empty",
                self.__class__.__name__,
            )
            df = self._create_empty_df()
            self._validate_df(df)
            self.gate_parameters_df = df
            self.solutions_hash = None

    @classmethod
    def from_h5(cls, path: typing.Union[str, pathlib.Path]) -> "GateSolution":
        """Load a set of calibrations from a datafile."""
        path = pathlib.Path(path)
        assert path.exists() and path.is_file()
        assert path.suffix in (".h5", ".hdf5")

        # read data
        with pd.HDFStore(path, mode="r") as storage:
            df = pd.DataFrame(storage.get(cls._HDF_KEYS["df"]))
        with h5py.File(path, mode="r") as storage:
            df_temp = storage.get(cls._HDF_KEYS["df"])
            solution_hash = df_temp.attrs[cls._HDF_KEYS["hash"]]
            num_ions = df_temp.attrs[cls._HDF_KEYS["ions"]]
            mod_time = df_temp.attrs[cls._HDF_KEYS["modify_time"]]
            solution_path = storage.get(cls._HDF_KEYS["solution_path"])[()]

        # Check that we did not break back compatibility by checking file has recently added columns

        new_columns = {
            "XX_angle": np.pi/4,      # Column name and default value
        }
        for icol in new_columns.keys():
            try:
                df.loc[:,icol]
            except KeyError:
                _LOGGER.debug(
                    "Did not find the column labeled %s, setting to default value %f",
                    icol,
                    new_columns[icol],
                )
                #Make the column in the df and set it to the default value
                df[icol] = np.nan
                ind_gates = df["XX_gate_type"].notnull()
                df.loc[ind_gates, icol] = new_columns[icol]


        _LOGGER.debug(
            "Loaded %i-ion XX gate parameters: %s, saved @ %s, solution set: %s",
            num_ions,
            df.shape,
            mod_time,
            solution_path,
        )

        return cls(
            num_ions,
            dataframe=df,
            solutions_hash=solution_hash,
            modify_time=mod_time,
            path=solution_path,
        )

    def to_h5(self, path: typing.Union[str, pathlib.Path]) -> None:
        """Store a Gate Solution in an HDF5 file for future retrieval/analysis."""
        path = pathlib.Path(path)
        assert path.suffix in (".h5", ".hdf5")
        if path.is_file():
            _LOGGER.info("Deleting & overwriting existing file: `%s`", path)
            os.remove(str(path))

        # store data
        save_time = time.strftime("%a, %d %b %Y %H:%M:%S %z", time.gmtime())
        if self.solutions_hash is None:
            # TODO: add parameter to recalculate solution hash when update
            # the parameters. Might want to either have arg to this function
            # or have flag set when update_parameters() called.
            # used when creating solutions from scratch, will hash
            # the dataframe and then use that for future
            self.solutions_hash = hashlib.sha256(
                pd.util.hash_pandas_object(
                    self.gate_parameters_df.dropna().apply(eur_hash.make_hash), index=True
                ).values
            ).hexdigest()

        with pd.HDFStore(path, mode="a") as storage:
            storage.put(self._HDF_KEYS["df"], self.gate_parameters_df)
        with h5py.File(path) as storage:
            df = storage[self._HDF_KEYS["df"]]
            df.attrs[self._HDF_KEYS["hash"]] = self.solutions_hash
            df.attrs[self._HDF_KEYS["ions"]] = self.num_ions
            df.attrs[self._HDF_KEYS["modify_time"]] = self._modify_time
            df.attrs[self._HDF_KEYS["save_time"]] = save_time
            storage[self._HDF_KEYS["solution_path"]] = str(self.load_path)

    def update_gate(
        self,
        slot_pair: common_types.SlotPair,
        gate_param: common_types.XXGateParams,
        convert_ions_to_slots: bool = False,
        **kwargs
    ) -> None:
        """Set the gate parameters of a certain slot pair.

        Set ``convert_ions_to_slots=True`` if you want to pass an ion pair.
        """
        if convert_ions_to_slots:
            slot_pair = tuple(map(self._ion_to_slot_func, slot_pair))
        if slot_pair not in self.possible_indices:
            raise ValueError("Invalid slot gate pair updated: {}".format(slot_pair))

        if gate_param.__class__ == common_types.XXGateParams:
            for ifield in gate_param._fields:
                self.gate_parameters_df.loc[slot_pair, ifield] = getattr(gate_param, ifield)
        else:
            _LOGGER.debug("gate_param arg is not an XXGateParams named tuple, "
                          "pass data in as kwargs if you wish to bypass the named tuple ")


        for kw, value in kwargs.items():
            if kw in self.df_columns:
                self.gate_parameters_df.loc[slot_pair, kw] = value
            else:
                raise ValueError(
                    "Kwarg {} is not in dataframe (valid cols = {})".format(
                        kw, self.df_columns
                    )
                )
        self._modify_time = time.gmtime()

    def __getattr__(self, attr: str):
        """Pass gate lookups to internal dataframe.

        Raises :class:`AttributeError` if invalid. This method only runs if a
        requested attribute does not already exist in this class.
        """
        return getattr(self.gate_parameters_df, attr)

    def _validate_df(self, pandas_object: pd.DataFrame) -> bool:
        """Validate the :class:`pandas.DataFrame` is of the correct type."""
        if isinstance(pandas_object, pd.DataFrame):
            obj_no_na = pandas_object.dropna()
            assert all(obj_no_na.columns.isin(self.df_columns))
            assert all(obj_no_na.index.isin(self.possible_indices))
            assert (
                obj_no_na
                .loc[:, "XX_gate_type"]
                .isin((common_types.XXModulationType))
            ).all()  # TODO: maybe all same?
            # assert (obj_no_na.loc[:, "XX_duration_us"]).all()
            assert all(obj_no_na.loc[:, "XX_sign"].isin((-1, +1, np.nan)))
            # assert all(
            #     pandas_object.loc[:, "XX_amplitudes"]
            # )  # lengths are all equal and maybe valid floats?
            # TODO: add more validations?? Check amplitudes, maybe? Check index?

            return True
        else:
            raise TypeError(
                "Arg type ({}) is not a Pandas Dataframe".format(type(pandas_object))
            )

    def _validate_hash(self, soln_hash: str) -> bool:
        """Check the hash string is a valid hash.

        Don't do anything too precise, just check it has roughly the right
        number of bits and is a hex string.
        """
        assert len(soln_hash) > 40, "Hash is too short to be valid"
        assert all(c in string.hexdigits for c in soln_hash)
        return True  # if no errors

    def _df_index_and_cols(self) -> typing.Tuple[pd.MultiIndex, typing.Sequence[str]]:
        """Return the default index and columns for a set of gate parameters.

        Used for constructing new dataframes.
        """
        index = pd.MultiIndex.from_tuples(self.possible_indices)
        cols = self.df_columns
        return index, cols

    def _create_empty_df(self, index: pd.MultiIndex = None) -> pd.DataFrame:
        """Create an empty gate solution dataframe."""
        def_index, cols = self._df_index_and_cols()
        if index is None:
            index = def_index
        return pd.DataFrame(index=index, columns=cols, dtype=object)

    @property
    def last_modification_time(self) -> time.struct_time:
        """Get time of last modification to solution."""
        return self._modify_time

    @property
    def df_columns(self) -> typing.Sequence[str]:
        """Return all column names in the internal dataframe.

        Returns valid names even if dataframe is not yet instantiated.
        """
        return list(
            itertools.chain(
                common_types.XXGateParams._fields, self._EXTRA_DF_COLUMNS.keys(),
            )
        )

    @property
    def possible_indices(self) -> typing.Sequence[common_types.SlotPair]:
        """Return all possible indices in this data structure."""
        return self._possible_slots

    def load_gate_solutions(self, path: typing.Union[str, pathlib.Path]) -> None:
        """Load gate solutions from a directory path."""
        path = pathlib.Path(path)
        assert path.is_dir()

        dir_hash = eur_hash.hashdir(path)

        # get a list of Ion Gate pairs listed in the directory
        gates_solved = [
            tuple(map(int, solution_path.stem.split("-")))
            for solution_path in path.glob(common_types.SOLUTION_FILENAME_GLOB_PATTERN)
        ]
        _LOGGER.debug("Found solutions for the following ion pairs: %s", gates_solved)

        # Convert gates_solved to equivalent slots
        slots_solved = list(
            sliced(tuple(map(self._ion_to_slot_func, flatten(gates_solved))), 2)
        )

        index = pd.MultiIndex.from_tuples(slots_solved, names=self._GATE_INDEX_NAMES)

        self.gate_parameters_df = self._create_empty_df(index)

        for sol_file in path.glob(common_types.SOLUTION_FILENAME_GLOB_PATTERN):
            _LOGGER.debug("Parsing gate solutions file '%s'", sol_file)
            ions = tuple(map(int, sol_file.stem.split("-")))  # "08-09.sol" -> (8, 9)
            assert len(ions) == 2, "Incorrect filename format"

            with sol_file.open(mode="rb") as f:
                read_params = pickle.load(f)
                read_params[0] = common_types.XXModulationType(read_params[0])
                gate_sol_params = common_types.XXGateParams(*read_params)

            _LOGGER.debug("Ions %s Gate Params: %s", ions, gate_sol_params)
            self.update_gate(ions, gate_sol_params, convert_ions_to_slots=True)

        assert dir_hash == eur_hash.hashdir(path), "solutions changed while loading"

        self.solutions_hash = dir_hash
        self.load_path = path


class GateCalibrations(GateSolution):
    """A data structure for calibrations to be applied to :class:`GateSolutions`."""

    _HDF_KEYS = {
        # names to HDF key mappings, used for storing data to HDF file.
        "ions": "number_of_ions",
        "df": "gate_calibrations_df",
        "hash": "solutions_hash",
        "modify_time": "calibration_modify_timestamp",
        "save_time": "calibration_save_timestamp",
        "solution_path": "solution_location_path",
    }

    # mapping from name to default value
    _EXTRA_DF_COLUMNS = {
        "global_amplitude": 1000,  # Global beam amplitude
        # imbalance in amplitude between the red & blue sidebands
        "sideband_amplitude_imbalance": 0.0,
        # common-mode amplitude scaling (individual beams)
        "individual_amplitude_multiplier": 1.0,
        # imbalance in amplitude between beams on the two ions in the gate
        "individual_amplitude_imbalance": 0.0,
        "stark_shift": 0.0,  # stark shift that this gate applies, common-mode
        "stark_shift_differential": 0.0,  # differential individual frequencies
        # modifies motional frequency from gate solution
        "motional_frequency_adjust": 0.0,
    }

    GLOBAL_CALIBRATION_SLOT = (-1, -1)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Add global calibration as a possible slot. Initialize to 0
        self.gate_parameters_df.loc[self.GLOBAL_CALIBRATION_SLOT, :] = 0
        self.gate_parameters_df.loc[self.GLOBAL_CALIBRATION_SLOT, "XX_sign"] = np.nan

    @property
    def possible_indices(self) -> typing.Sequence[common_types.SlotPair]:
        """Add the global calibration slot to possible indices from GateSolutions."""
        return super().possible_indices + [self.GLOBAL_CALIBRATION_SLOT]

    @classmethod
    def from_gate_solution(cls, gate_sol: GateSolution) -> "GateCalibrations":
        """Copy -ish the internals of a :class:`Gatesolution`.

        Allows/Expects filling in calibrations later.
        """
        ions = copy.copy(gate_sol.num_ions)
        df = gate_sol.gate_parameters_df.copy()
        soln_hash = copy.copy(gate_sol.solutions_hash)
        new_tweaks = cls(
            ions, dataframe=df, solutions_hash=soln_hash, modify_time=time.gmtime()
        )
        new_tweaks.load_gate_solutions(None)  # copy gate types & clear DF
        return new_tweaks

    def _validate_df(self, pandas_object: pd.DataFrame) -> bool:
        """Allow all-NaN dataframes, or those that are valid :class:`GateSolution`."""
        return pandas_object.dropna().empty or super()._validate_df(pandas_object)

    def load_gate_solutions(self, path: typing.Union[str, pathlib.Path] = None):
        """Load a BLANK/EMPTY calibration dataframe from gate solutions.

        If you would like to load existing calibrations, use :meth:`from_h5` or
        :meth:`to_h5`.

        Args:
            path (str, pathlib.Path): Path where the existing gate solutions have been
                stored, such as the outputs from Laird's gate solutions calculator.
        """
        if path is not None:
            super().load_gate_solutions(path)
        loaded_gate_types = self.gate_parameters_df.loc[:, "XX_gate_type"]
        # Kinda wipe out whatever happened in super(), b/c want to init DF to NaN
        self.gate_parameters_df = self._create_empty_df()
        self.gate_parameters_df.loc[:, "XX_gate_type"] = loaded_gate_types
        self.gate_parameters_df = self.gate_parameters_df.fillna(self._EXTRA_DF_COLUMNS)
        xxgateparam_defaults = {
            "XX_gate_type": np.nan,
            "XX_detuning": 0,
            "XX_sign": np.nan,
            "XX_duration_us": 0.0,
            "XX_amplitudes": 0,
        }
        # fill gate parameter defaults
        self.gate_parameters_df = self.gate_parameters_df.fillna(xxgateparam_defaults)

    def update_gate(
        self,
        slot_pair: common_types.SlotPair,
        gate_param: common_types.XXGateParams = None,
        convert_ions_to_slots: bool = False,
        **kwargs
    ) -> None:
        """Update Gate Calibration parameters.

        Args:
            slot_pair (common_types.SlotPair): A specific slot pair to address
            gate_param (common_types.XXGateParams, optional):
                Set of XX Gate Params to override. Defaults to None.
            convert_ions_to_slots (bool): Set ``True`` you pass an IonPair
                instead of a SlotPair.

        Kwargs:
            Any item in :attr:`self.df_columns` is a valid key, and the value
            can be any value.
            This function will check that the key is a valid item before setting.
        """
        if gate_param is None:
            # default to re-writing current value to avoid re-writing super method
            gate_param = self.gate_parameters_df.loc[
                slot_pair, "XX_gate_type":"XX_amplitudes"
            ]
        return super().update_gate(
            slot_pair, gate_param, convert_ions_to_slots=convert_ions_to_slots, **kwargs
        )


# TODO: UNFINISHED
# def get_calibrated_gate(
#     ideal_solution: GateSolution,
#     calibration: GateCalibrations = None,
#     ion_pair: common_types.IonPair = None,
# ) -> typing.Union[common_types.XXGateParams, GateSolution]:
#     """Calculate the gate parameters for a calibrated gate."""
#     assert ideal_solution.num_ions == calibration.num_ions
#     assert ideal_solution.solutions_hash == calibration.solutions_hash
#     assert calibration.last_modification_time > ideal_solution.last_modification_time
#     if calibration is None:
#         _LOGGER.warning("Using un-calibrated gate solution. Probably a bad idea.")
#         calibration = GateCalibrations.from_gate_solution(ideal_solution)
#     if ion_pair is not None:
#         assert ion_pair in ideal_solution.index and ion_pair in calibration.index
#         return common_types.XXGateParams(
#             ideal_solution.loc[ion_pair, :] + calibration[ion_pair, :]
#         )
#     else:
#         # TODO: only add certain columns (i.e. not types, sign(?))
#         data = ideal_solution.gate_parameters_df + calibration.gate_parameters_df
#         # only allows calibrated gates to propagate??
#         # df = pd.DataFrame(
#         #     data=data, index=calibration.index, columns=ideal_solution.columns
#         # )
#         return GateSolution(
#             ideal_solution.num_ions,
#             dataframe=data,
#             solutions_hash=ideal_solution.solutions_hash,
#         )
